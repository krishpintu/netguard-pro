import React, { useEffect, useRef, useState } from "react";

export interface HostItem {
  name: string;
  lastvalue: string;
  itemid: string;
  groupid?: string;
}

interface HoneycombProps {
  items: HostItem[];
  cardWidth: number;
  cardHeight: number;
}

const BASE_CELL_WIDTH = 92;
const BASE_CELL_HEIGHT = 80;
const SMALL_CONTAINER_WIDTH = 200;

const TestHoneycomb: React.FC<HoneycombProps> = ({ items }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const initialHeightRef = useRef<number | null>(null);

  const [rows, setRows] = useState<HostItem[][]>([]);
  const [cellSize, setCellSize] = useState({
    width: BASE_CELL_WIDTH,
    height: BASE_CELL_HEIGHT,
  });

  const hoverScale = 2.2;
  const basePadding = 5;

  /* =====================================================
     EDGE-AWARE HOVER TRANSFORM
  ===================================================== */
  const applyHoverTransform = (
    cell: HTMLDivElement,
    container: HTMLDivElement,
    scale: number,
  ) => {
    const cellRect = cell.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    const scaledWidth = cellRect.width * scale;
    const scaledHeight = cellRect.height * scale;

    let translateX = 0;
    let translateY = 0;

    const overflowLeft =
      containerRect.left - (cellRect.left - (scaledWidth - cellRect.width) / 2);
    const overflowRight =
      cellRect.right + (scaledWidth - cellRect.width) / 2 - containerRect.right;
    const overflowTop =
      containerRect.top - (cellRect.top - (scaledHeight - cellRect.height) / 2);
    const overflowBottom =
      cellRect.bottom +
      (scaledHeight - cellRect.height) / 2 -
      containerRect.bottom;

    if (overflowLeft > 0) translateX += overflowLeft;
    if (overflowRight > 0) translateX -= overflowRight;
    if (overflowTop > 0) translateY += overflowTop;
    if (overflowBottom > 0) translateY -= overflowBottom;

    cell.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  };

  useEffect(() => {
    if (!containerRef.current) return;

    const buildRows = (width: number, height: number) => {
      if (initialHeightRef.current === null) {
        initialHeightRef.current = height;
      }

      /* VERY NARROW CONTAINER */
      if (width < SMALL_CONTAINER_WIDTH) {
        setCellSize({
          width: BASE_CELL_WIDTH,
          height: BASE_CELL_HEIGHT,
        });
        setRows(items.map((item) => [item]));
        return;
      }

      /* HEIGHT-DRIVEN SCALING */
      const scale = Math.max(1, height / initialHeightRef.current);
      let scaledWidth = BASE_CELL_WIDTH * scale;
      let scaledHeight = BASE_CELL_HEIGHT * scale;

      const horizontalOffset = -0.13 * scaledWidth;
      const maxPerRow = Math.max(
        1,
        Math.floor(width / (scaledWidth + horizontalOffset)),
      );
      const maxAllowedWidth = width / maxPerRow - horizontalOffset;

      if (scaledWidth > maxAllowedWidth) {
        const ratio = maxAllowedWidth / scaledWidth;
        scaledWidth = maxAllowedWidth;
        scaledHeight *= ratio;
      }

      scaledWidth = Math.max(scaledWidth, BASE_CELL_WIDTH);
      scaledHeight = Math.max(scaledHeight, BASE_CELL_HEIGHT);

      setCellSize({ width: scaledWidth, height: scaledHeight });

      /* BUILD STAGGERED ROWS */
      const result: HostItem[][] = [];
      let index = 0;
      let toggle = true;

      while (index < items.length) {
        const rowLength = toggle ? maxPerRow : Math.max(1, maxPerRow - 1);
        result.push(items.slice(index, index + rowLength));
        index += rowLength;
        toggle = !toggle;
      }

      setRows(result);
    };

    buildRows(
      containerRef.current.offsetWidth,
      containerRef.current.offsetHeight,
    );

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        buildRows(width, height);
      }
    });

    resizeObserver.observe(containerRef.current);
    return () => resizeObserver.disconnect();
  }, [items]);

  /* ===========================
     CALCULATE GAPS
  =========================== */
  const horizontalGap = cellSize.width * 0.88;
  const verticalGap = cellSize.height * 0.75;

  return (
    <div ref={containerRef} className="honeycomb-wrapper w-full h-full">
      <style>{`
        .honeycomb-wrapper {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          width: 100%;
          height: 100%;
          overflow-x: hidden; 
          overflow-y: auto;   
        }

        .honeycomb-row {
          display: flex;
        }

        .honeycomb-cell-wrapper {
          position: relative;
          clip-path: polygon(
            50% 0%, 93% 25%, 93% 75%,
            50% 100%, 7% 75%, 7% 25%
          );
          transition: transform 0.35s ease;
          transform-origin: center;
        }

        .honeycomb-cell-wrapper:hover {
          z-index: 20;
        }

        .honeycomb-cell {
          position: absolute;
          inset: 1px;
          clip-path: inherit;
          display: flex;
          align-items: center;
          justify-content: center;
        }
      `}</style>

      {rows.map((row, rowIndex) => {
        const isOddRow = rowIndex % 2 !== 0;
        const rowPaddingLeft = isOddRow ? horizontalGap / 2 : 0;

        return (
          <div
            key={rowIndex}
            className="honeycomb-row"
            style={{
              paddingLeft: rowPaddingLeft,
              marginBottom: -cellSize.height * 0.23, // maintain vertical overlap
            }}
          >
            {row.map((item) => {
              const isUp = item.lastvalue === "1";

              return (
                <div
                  key={item.itemid}
                  className="honeycomb-cell-wrapper"
                  style={{
                    width: cellSize.width,
                    height: cellSize.height,
                    marginRight: horizontalGap - cellSize.width,
                    background: isUp ? "#245414" : "#c4430d",
                  }}
                  onMouseEnter={(e) => {
                    if (!containerRef.current) return;
                    applyHoverTransform(
                      e.currentTarget,
                      containerRef.current,
                      hoverScale,
                    );
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.transform = "scale(1)";
                  }}
                >
                  <div
                    className="honeycomb-cell"
                    style={{
                      backgroundColor: isUp ? "#347b1c" : "#ff5b11",
                      color: "white",
                    }}
                  >
                    <span
                      style={{
                        fontSize: "12px",
                        padding: "15px",
                        textAlign: "center",
                        display: "block",
                        width: "100%",
                        whiteSpace: "nowrap",
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                      }}
                    >
                      {item.name}
                    </span>
                  </div>
                </div>
              );
            })}
          </div>
        );
      })}
    </div>
  );
};

export default TestHoneycomb;
